var e = { d: (t, s) => { for (var n in s) e.o(s, n) && !e.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: s[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t) }, t = {}; e.d(t, { $: () => K, i: () => S }); class s { constructor(e) { this.messageReceiver = e } notify(e, t) { this.messageReceiver.onMessageReceived(e, t) } } class n { constructor() { this.values = {} } add(e, t) { this.getValuesAtKey(e).push(t) } remove(e, t) { const s = this.values[e]; if (s) { const e = s.indexOf(t); e > -1 && s.splice(e, 1) } } removeKey(e) { delete this.values[e] } getValuesAtKey(e) { const t = this.values[e] || []; return this.values[e] = t, t } valuesPerKey(e) { return this.getValuesAtKey(e).length } find(e, t) { return this.values[e] && this.values[e].find(t) } get keys() { return Object.keys(this.values) } hasKey(e) { return e in this.values } has(e, t) { return this.hasKey(e) && this.values[e].includes(t) } *[Symbol.iterator]() { for (const e in this.values) for (const t of this.values[e]) yield [e, t] } } Symbol.iterator; class r { listen() { } stopListening() { } send() { throw Error("The sdk has been disconnected and can't make any new calls") } } class i { constructor(e, t, s) { this.sourceId = e, this.targetId = t, this.messageBridge = s, this.observers = new n } static toFilteredMessenger(e, t, s) { const n = new o(e.sourceId, e.targetId, e, t); for (const t of s) for (const s of e.observers.getValuesAtKey(t)) n.addObserver(s); return n } init() { const e = new class { constructor(e) { this.messenger = e } onMessageReceived(e, t) { this.messenger.onMessageReceived(e, t) } }(this), t = new s(e); this.messageBridge.listen(t) } dispose() { this.messageBridge.stopListening(), this.messageBridge = new r } addObserver(e) { this.observers.add(e.messageType, e) } removeObserver(e) { this.observers.remove(e.messageType, e) } send(e) { const t = this.sourceId, s = this.targetId; this.messageBridge.send(Object.assign(Object.assign({}, e), { fromId: t, toId: s, timestamp: Date.now() })) } onMessageReceived(e, t) { if (!this.filterMessageId(e)) return; const s = e.type, n = this.observers.getValuesAtKey(s); if (n) for (const s of n) { const n = e.payload || e; s.notify(n, t, e.timestamp) } } filterMessageId(e) { const t = e.toId, s = e.fromId; return t instanceof Array ? t.indexOf(this.sourceId) > -1 : (void 0 === t || t === this.sourceId) && s === this.targetId } } class o extends i { constructor(e, t, s, n) { super(e, t, new r), this.messenger = s, this.sendFilter = n, this.errorBridge = new r } send(e) { this.sendFilter.includes(e.type) ? this.messenger.send(e) : this.errorBridge.send() } } class c { constructor(e, t) { this.sourceId = e, this.listenerBridge = t, this.observers = new n } init() { const e = new class { constructor(e) { this.messenger = e } onMessageReceived(e, t) { this.messenger.onMessageReceived(e, t) } }(this), t = new s(e); this.listenerBridge.listen(t) } dispose() { this.listenerBridge.stopListening() } addObserver(e) { this.observers.add(e.messageType, e) } removeObserver(e) { this.observers.remove(e.messageType, e) } send(e, t, s, n) { s.send(Object.assign(Object.assign({}, e), { fromId: this.sourceId, toId: t, timestamp: Date.now() }), n) } onMessageReceived(e, t) { const s = e.type, n = this.observers.getValuesAtKey(s); if (n) for (const s of n) { const n = e.payload || e; s.notify(n, t, e.timestamp) } } } class a { constructor(e) { this.targetWindow = e, this.messageObserver = null, this.onMessage = e => { if (this.messageObserver) { const t = e.data; this.messageObserver.notify(Object.assign({}, t), { id: t.fromId, origin: e.origin, source: e.source }, e.data.timestamp) } } } listen(e) { this.messageObserver || (this.messageObserver = e, this.targetWindow.addEventListener("message", this.onMessage)) } stopListening() { this.targetWindow.removeEventListener("message", this.onMessage), this.messageObserver = null } } class h { constructor(e, t = "*") { this.targetWindow = e, this.targetOrigin = t } send(e, t) { this.targetWindow.postMessage(e, this.targetOrigin) } } class d { constructor(e, t, s = "*") { this.sourceWindow = e, this.listener = new a(e), this.sender = new h(t, s) } listen(e) { this.listener.listen(e) } stopListening() { this.listener.stopListening() } send(e) { this.sender.send(e, this.sourceWindow) } } class l { constructor(e, t, s, n, r = "*") { this.sourceId = e, this.sourceWindow = t, this.targetId = s, this.targetWindow = n, this.targetOrigin = r } createMessenger() { const e = new d(this.sourceWindow, this.targetWindow, this.targetOrigin); return new i(this.sourceId, this.targetId, e) } } var u = function (e, t, s, n) { return new (s || (s = Promise))((function (r, i) { function o(e) { try { a(n.next(e)) } catch (e) { i(e) } } function c(e) { try { a(n.throw(e)) } catch (e) { i(e) } } function a(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof s ? t : new s((function (e) { e(t) }))).then(o, c) } a((n = n.apply(e, t || [])).next()) })) }; class g { constructor() { this.libraryCache = new Map } load(e, t) { const s = this.libraryCache.get(e) || new v(e, t); return this.libraryCache.set(e, s), s.library } } class v { constructor(e, t) { this._libraryPromise = new Promise(((e, t) => { this.libraryResolver = e, this.libraryRejecter = t })), this.fetch(e, t) } fetch(e, t) { return u(this, void 0, void 0, (function* () { try { const s = yield import(e), n = Object.assign({}, s); if (t && t in window) { const e = window[t] || {}; Object.assign(n, e), delete window[t] } this.libraryResolver(n) } catch (e) { this.libraryRejecter(e) } })) } get library() { return this._libraryPromise } } var m, p, f, y, w = function (e, t, s, n) { return new (s || (s = Promise))((function (r, i) { function o(e) { try { a(n.next(e)) } catch (e) { i(e) } } function c(e) { try { a(n.throw(e)) } catch (e) { i(e) } } function a(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof s ? t : new s((function (e) { e(t) }))).then(o, c) } a((n = n.apply(e, t || [])).next()) })) }; !function (e) { const t = new g; e.connect = function (e, s, n) { return w(this, void 0, void 0, (function* () { let r; try { r = yield e.connect() } finally { e.cancelConnecting() } const i = yield function (e) { return w(this, void 0, void 0, (function* () { if (!e) throw new Error("Unabled to load the sdk"); try { const s = yield t.load(e, "sdk-client"); if (s && s.SdkBuilder && "function" == typeof s.SdkBuilder) return s.SdkBuilder } catch (e) { } throw Error(`Could not load the sdk from ${e}`) })) }(r.scriptUrl), o = s.getFactory(r); return function (e, t, s, n) { return new t(s, e).build(n) }(n, i, o, r.serializedInterface) })) } }(m || (m = {})), function (e) { e.CONNECT = "postmessage.connect" }(p || (p = {})), function (e) { e.HANDSHAKE = "postmessage.handshake", e.ACCEPT = "postmessage.accept", e.REJECT = "postmessage.reject" }(f || (f = {})); class b { constructor(e, t = {}) { this.type = p.CONNECT, this.payload = { bootstrapVersion: e, options: { auth: t.auth, provider: t.provider, sdkType: t.sdkType }, applicationKey: t.applicationKey } } } class E { constructor(e) { this.receiver = e, this.messageType = f.HANDSHAKE } notify(e, t, s) { this.receiver.handshake() } } class O { constructor(e) { this.receiver = e, this.messageType = f.ACCEPT } notify(e, t, s) { const { sourceId: n, scriptUrl: r, targetId: i, targetOrigin: o } = e, c = e.interface; this.receiver.accept(n, r, c, i, o) } } !function (e) { e.CANCELLED = "ConnectionCancelled", e.REFUSED = "ConnectionRefused", e.INVALID_PROVIDER = "InvalidProvider", e.KEY_MISMATCH = "KeyReferrerMismatch" }(y || (y = {})); class C extends Error { constructor() { super(), this.type = y.REFUSED, this.name = "ConnectionRefusedError" } } class I extends Error { constructor(e) { super(e), this.type = y.INVALID_PROVIDER, this.name = "InvalidProviderError" } } class N extends Error { constructor(e) { super(e), this.type = y.KEY_MISMATCH, this.name = "KeyReferrerMismatchError" } } const D = { [y.REFUSED]: C, [y.KEY_MISMATCH]: N, [y.INVALID_PROVIDER]: I }; class R { constructor(e) { this.receiver = e, this.messageType = f.REJECT } notify(e, t, s) { const n = D[e.errorType]; if (n) { const t = new n(e.reason); this.receiver.reject(t) } } } class T extends Error { constructor(e) { super(e), this.type = y.CANCELLED, this.name = "ConnectionCancelledError" } } var P; !function (e) { e[e.IDLE = 0] = "IDLE", e[e.CONNECTING = 1] = "CONNECTING", e[e.HANDSHAKE = 2] = "HANDSHAKE", e[e.CONNECTED = 3] = "CONNECTED", e[e.REJECTED = 4] = "REJECTED" }(P || (P = {})); class A { constructor(e, t, s) { this.messenger = e, this.target = t, this.source = s, this.connectionState = P.IDLE, this.connectionPoll = void 0; const n = new class { constructor(e) { this.connector = e } handshake() { this.connector.handshake() } accept(e, t, s, n, r) { this.connector.accept(e, t, s, n, r) } reject(e) { this.connector.reject(e) } }(this); this.handshakeObserver = new E(n), this.acceptObserver = new O(n), this.rejectObserver = new R(n), this.connectionPromise = new Promise(((e, t) => { this.resolveConnection = e, this.rejectConnection = t })) } connect(e, t = {}) { return this.connectionState === P.IDLE && (this.connectionState = P.CONNECTING, this.messenger.addObserver(this.handshakeObserver), this.messenger.addObserver(this.acceptObserver), this.messenger.addObserver(this.rejectObserver), this.connectionPoll = window.setInterval((() => { this.messenger.send(new b(e, t), -1, this.target, this.source) }), 500)), this.connectionPromise } cancelConnecting() { this.connectionState < P.CONNECTED && (this.stopConnectPolling(), this.rejectConnection(new T("User manually cancelled connection"))) } handshake() { this.connectionState < P.HANDSHAKE && (this.connectionState = P.HANDSHAKE, this.stopConnectPolling(), this.messenger.removeObserver(this.handshakeObserver)) } accept(e, t, s, n, r) { this.connectionState < P.CONNECTED && (this.connectionState = P.CONNECTED, this.messenger.removeObserver(this.handshakeObserver), this.messenger.removeObserver(this.acceptObserver), this.messenger.removeObserver(this.rejectObserver), this.stopConnectPolling(), this.resolveConnection({ sourceId: e, targetId: n, targetOrigin: r, scriptUrl: t, serializedInterface: s })) } reject(e) { this.connectionState < P.CONNECTED && (this.connectionState = P.REJECTED, this.messenger.removeObserver(this.handshakeObserver), this.messenger.removeObserver(this.acceptObserver), this.messenger.removeObserver(this.rejectObserver), this.stopConnectPolling(), this.rejectConnection(e)) } stopConnectPolling() { clearInterval(this.connectionPoll), this.connectionPoll = void 0 } } var M = function (e, t, s, n) { return new (s || (s = Promise))((function (r, i) { function o(e) { try { a(n.next(e)) } catch (e) { i(e) } } function c(e) { try { a(n.throw(e)) } catch (e) { i(e) } } function a(e) { var t; e.done ? r(e.value) : (t = e.value, t instanceof s ? t : new s((function (e) { e(t) }))).then(o, c) } a((n = n.apply(e, t || [])).next()) })) }; const S = "3.0"; function K(e, t = {}) { return M(this, void 0, void 0, (function* () { return "string" == typeof t ? function (e, t) { return console.warn("MP_SDK: connecting using an `applicationKey` argument is deprecated. Please add the key to the iframe's URL parameters instead."), j(e, { applicationKey: t }) }(e, t) : j(e, t) })) } function j(e, t = {}) { const s = (n = e).contentWindow ? n.contentWindow : null; var n; if (!s) return Promise.reject("invalid window"); const r = Math.floor(1e6 * Math.random()), i = new a(window), o = new h(s), d = new c(r, i); d.init(); const l = new A(d, o, window); return m.connect(new k(l, d, t), new L(s), window) } class k { constructor(e, t, s) { this.connector = e, this.postMessage = t, this.options = s } connect() { return this.connector.connect(S, this.options) } cancelConnecting() { this.postMessage.dispose() } } class L { constructor(e) { this.target = e } getFactory(e) { return new l(e.sourceId, window, e.targetId, this.target, e.targetOrigin) } } var H = t.$, x = t.i; export { H as connect, x as version };
